package com.runon.app

import android.app.Activity
import android.content.Intent
import android.util.Log
import com.facebook.react.bridge.*
import com.facebook.react.modules.core.DeviceEventManagerModule
import com.samsung.android.sdk.healthdata.*
import com.samsung.android.sdk.healthdata.HealthDataStore.ConnectionListener
import com.samsung.android.sdk.healthdata.HealthDataStore.ConnectionResult
import com.samsung.android.sdk.healthdata.HealthPermissionManager.PermissionKey
import com.samsung.android.sdk.healthdata.HealthPermissionManager.PermissionType
import java.text.SimpleDateFormat
import java.util.*

class SamsungHealthModule(reactContext: ReactApplicationContext) : ReactContextBaseJavaModule(reactContext), ConnectionListener {
    
    private val TAG = "SamsungHealthModule"
    private var healthDataStore: HealthDataStore? = null
    private var permissionManager: HealthPermissionManager? = null
    private var dataResolver: HealthDataResolver? = null
    private var isConnected = false
    private var permissionRequestCode = 1
    
    // Health Data Types
    private val EXERCISE_DATA_TYPE = "com.samsung.shealth.exercise"
    private val EXERCISE_ROUTE_DATA_TYPE = "com.samsung.shealth.exercise_route"
    
    init {
        try {
            healthDataStore = HealthDataStore(reactContext.applicationContext, this)
            healthDataStore?.connectService()
            permissionManager = HealthPermissionManager(healthDataStore)
            dataResolver = HealthDataResolver(healthDataStore, null)
        } catch (e: Exception) {
            Log.e(TAG, "Samsung Health SDK 초기화 실패", e)
        }
    }
    
    override fun getName(): String {
        return "SamsungHealth"
    }
    
    // HealthKit과 동일한 인터페이스 제공
    @ReactMethod
    fun isAvailable(promise: Promise) {
        try {
            val result = healthDataStore != null && isConnected
            promise.resolve(result)
        } catch (e: Exception) {
            Log.e(TAG, "isAvailable 실패", e)
            promise.reject("ERROR", "Samsung Health 사용 가능 여부 확인 실패: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun checkPermissions(promise: Promise) {
        try {
            if (healthDataStore == null || !isConnected) {
                promise.resolve(createReactMap().apply {
                    putBoolean("isAvailable", false)
                    putBoolean("hasPermissions", false)
                    putString("error", "Samsung Health에 연결되지 않았습니다.")
                })
                return
            }
            
            val permissionKeys = getPermissionKeys()
            val permissionManager = HealthPermissionManager(healthDataStore)
            val permissionTypes = setOf(PermissionType.READ)
            
            val result = permissionManager.isPermissionAcquired(permissionKeys, permissionTypes)
            
            val response = createReactMap().apply {
                putBoolean("isAvailable", true)
                putBoolean("hasPermissions", result)
                putString("error", null)
            }
            
            promise.resolve(response)
        } catch (e: Exception) {
            Log.e(TAG, "checkPermissions 실패", e)
            promise.reject("ERROR", "권한 확인 실패: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun requestPermissions(promise: Promise) {
        try {
            val activity = currentActivity
            if (activity == null) {
                promise.reject("ERROR", "Activity를 찾을 수 없습니다.")
                return
            }
            
            if (healthDataStore == null || !isConnected) {
                promise.reject("ERROR", "Samsung Health에 연결되지 않았습니다.")
                return
            }
            
            val permissionKeys = getPermissionKeys()
            val permissionManager = HealthPermissionManager(healthDataStore)
            val permissionTypes = setOf(PermissionType.READ)
            
            // 이미 권한이 있으면 성공 반환
            if (permissionManager.isPermissionAcquired(permissionKeys, permissionTypes)) {
                promise.resolve(true)
                return
            }
            
            // 권한 요청
            try {
                permissionManager.requestPermissions(permissionKeys, permissionTypes)
                    .setResultListener { result ->
                        val isGranted = result.resultCode == Activity.RESULT_OK
                        promise.resolve(isGranted)
                    }
            } catch (e: Exception) {
                Log.e(TAG, "권한 요청 실패", e)
                promise.reject("ERROR", "권한 요청 실패: ${e.message}", e)
            }
        } catch (e: Exception) {
            Log.e(TAG, "requestPermissions 실패", e)
            promise.reject("ERROR", "권한 요청 처리 실패: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun getSamples(params: ReadableMap, promise: Promise) {
        try {
            if (healthDataStore == null || !isConnected) {
                promise.reject("ERROR", "Samsung Health에 연결되지 않았습니다.")
                return
            }
            
            val startDate = params.getString("startDate")
            val endDate = params.getString("endDate")
            val type = params.getString("type") ?: "Workout"
            
            if (startDate == null || endDate == null) {
                promise.reject("ERROR", "시작일과 종료일이 필요합니다.")
                return
            }
            
            val startTime = parseISOString(startDate)
            val endTime = parseISOString(endDate)
            
            // Exercise 데이터 조회
            val request = HealthDataResolver.ReadRequest.Builder()
                .setDataType(EXERCISE_DATA_TYPE)
                .setProperties(arrayOf(
                    "start_time",
                    "end_time",
                    "duration",
                    "distance",
                    "calorie",
                    "exercise_type"
                ))
                .setLocalTimeRange(
                    HealthConstants.TimeUnit.MILLISECONDS,
                    startTime,
                    endTime
                )
                .build()
            
            val results = mutableList<WritableMap>()
            
            dataResolver?.read(request)?.setResultListener { result ->
                try {
                    val iterator = result.iterator()
                    while (iterator.hasNext()) {
                        val data = iterator.next()
                        val workout = createWorkoutMap(data)
                        if (workout != null) {
                            results.add(workout)
                        }
                    }
                    
                    val response = createReactArray().apply {
                        for (workout in results) {
                            pushMap(workout)
                        }
                    }
                    
                    promise.resolve(response)
                } catch (e: Exception) {
                    Log.e(TAG, "데이터 읽기 실패", e)
                    promise.reject("ERROR", "데이터 읽기 실패: ${e.message}", e)
                }
            } ?: run {
                promise.reject("ERROR", "데이터 조회를 시작할 수 없습니다.")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "getSamples 실패", e)
            promise.reject("ERROR", "샘플 조회 실패: ${e.message}", e)
        }
    }
    
    @ReactMethod
    fun getWorkoutRouteSamples(params: ReadableMap, promise: Promise) {
        try {
            if (healthDataStore == null || !isConnected) {
                promise.reject("ERROR", "Samsung Health에 연결되지 않았습니다.")
                return
            }
            
            val workoutId = params.getString("id")
            if (workoutId == null) {
                promise.reject("ERROR", "워크아웃 ID가 필요합니다.")
                return
            }
            
            // Exercise Route 데이터 조회
            val request = HealthDataResolver.ReadRequest.Builder()
                .setDataType(EXERCISE_ROUTE_DATA_TYPE)
                .setProperties(arrayOf("latitude", "longitude", "time_offset"))
                .build()
            
            val results = mutableList<WritableMap>()
            
            dataResolver?.read(request)?.setResultListener { result ->
                try {
                    val iterator = result.iterator()
                    while (iterator.hasNext()) {
                        val data = result.next()
                        val location = createReactMap().apply {
                            putDouble("latitude", data.getDouble("latitude"))
                            putDouble("longitude", data.getDouble("longitude"))
                        }
                        results.add(location)
                    }
                    
                    val response = createReactArray().apply {
                        for (location in results) {
                            pushMap(location)
                        }
                    }
                    
                    promise.resolve(response)
                } catch (e: Exception) {
                    Log.e(TAG, "이동경로 데이터 읽기 실패", e)
                    promise.reject("ERROR", "이동경로 데이터 읽기 실패: ${e.message}", e)
                }
            } ?: run {
                promise.reject("ERROR", "이동경로 조회를 시작할 수 없습니다.")
            }
            
        } catch (e: Exception) {
            Log.e(TAG, "getWorkoutRouteSamples 실패", e)
            promise.reject("ERROR", "이동경로 샘플 조회 실패: ${e.message}", e)
        }
    }
    
    // ConnectionListener 구현
    override fun onConnected() {
        Log.d(TAG, "Samsung Health 연결 성공")
        isConnected = true
    }
    
    override fun onConnectionFailed(error: ConnectionResult) {
        Log.e(TAG, "Samsung Health 연결 실패: ${error.errorCode} - ${error.errorMessage}")
        isConnected = false
    }
    
    override fun onDisconnected() {
        Log.d(TAG, "Samsung Health 연결 해제")
        isConnected = false
    }
    
    // Helper 메서드들
    private fun getPermissionKeys(): Set<PermissionKey> {
        return setOf(
            PermissionKey(EXERCISE_DATA_TYPE, PermissionType.READ),
            PermissionKey(EXERCISE_ROUTE_DATA_TYPE, PermissionType.READ)
        )
    }
    
    private fun parseISOString(isoString: String): Long {
        return try {
            val sdf = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US)
            sdf.timeZone = TimeZone.getTimeZone("UTC")
            sdf.parse(isoString)?.time ?: 0L
        } catch (e: Exception) {
            Log.e(TAG, "날짜 파싱 실패: $isoString", e)
            0L
        }
    }
    
    private fun createWorkoutMap(data: HealthData): WritableMap? {
        return try {
            val workout = createReactMap()
            
            // Exercise type 확인 (Running = 10001)
            val exerciseType = data.getInt("exercise_type")
            if (exerciseType != 10001) { // Running이 아니면 null 반환
                return null
            }
            
            val startTime = data.getLong("start_time")
            val endTime = data.getLong("end_time")
            val duration = data.getLong("duration") / 1000 // 초 단위
            val distance = data.getFloat("distance").toDouble() // 미터 단위
            val calorie = data.getFloat("calorie").toDouble()
            
            // HealthKit과 동일한 형식으로 변환
            workout.putString("start", formatDate(startTime))
            workout.putString("end", formatDate(endTime))
            workout.putDouble("duration", duration.toDouble())
            workout.putDouble("distance", distance / 1609.34) // 미터를 마일로 변환 (HealthKit 형식)
            workout.putDouble("calories", calorie)
            workout.putString("activityName", "Running")
            workout.putInt("activityId", 1)
            
            workout
        } catch (e: Exception) {
            Log.e(TAG, "워크아웃 데이터 변환 실패", e)
            null
        }
    }
    
    private fun formatDate(timestamp: Long): String {
        val sdf = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US)
        sdf.timeZone = TimeZone.getTimeZone("UTC")
        return sdf.format(Date(timestamp))
    }
    
    private fun createReactMap(): WritableMap {
        return Arguments.createMap()
    }
    
    private fun createReactArray(): WritableArray {
        return Arguments.createArray()
    }
}

